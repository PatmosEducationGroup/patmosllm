/**
 * Document Generation Service
 * Generates PDF, PPTX, and XLSX files from chat content
 * Uses Puppeteer for PDF, PptxGenJS for PowerPoint, ExcelJS for spreadsheets
 */

import puppeteer from 'puppeteer'
import pptxgen from 'pptxgenjs'
import ExcelJS from 'exceljs'

export type DocumentFormat = 'pdf' | 'pptx' | 'xlsx'

export interface DocumentMetadata {
  title: string
  content: string
  sources?: Array<{ title: string; url?: string }>
  timestamp?: Date
}

/**
 * Generate PDF from markdown/HTML content using Puppeteer
 */
export async function generatePDF(metadata: DocumentMetadata): Promise<Buffer> {
  const { title, content, sources, timestamp = new Date() } = metadata

  // Create styled HTML template
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${escapeHtml(title)}</title>
  <style>
    @page {
      margin: 1in;
    }
    body {
      font-family: 'Georgia', serif;
      font-size: 12pt;
      line-height: 1.6;
      color: #333;
      max-width: 8.5in;
      margin: 0 auto;
    }
    h1 {
      color: #1e40af;
      font-size: 24pt;
      margin-bottom: 0.5em;
      border-bottom: 2px solid #1e40af;
      padding-bottom: 0.25em;
    }
    h2 {
      color: #1e40af;
      font-size: 18pt;
      margin-top: 1em;
      margin-bottom: 0.5em;
    }
    h3 {
      color: #374151;
      font-size: 14pt;
      margin-top: 0.75em;
      margin-bottom: 0.5em;
    }
    p {
      margin-bottom: 1em;
    }
    ul, ol {
      margin-bottom: 1em;
      padding-left: 2em;
    }
    li {
      margin-bottom: 0.5em;
    }
    .header {
      text-align: center;
      margin-bottom: 2em;
    }
    .metadata {
      color: #6b7280;
      font-size: 10pt;
      margin-bottom: 2em;
      text-align: center;
    }
    .sources {
      margin-top: 2em;
      padding-top: 1em;
      border-top: 1px solid #e5e7eb;
    }
    .sources h3 {
      color: #374151;
      font-size: 12pt;
    }
    .sources ul {
      list-style: none;
      padding-left: 0;
    }
    .sources li {
      margin-bottom: 0.5em;
      color: #4b5563;
      font-size: 10pt;
    }
    code {
      background-color: #f3f4f6;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 10pt;
    }
    pre {
      background-color: #f3f4f6;
      padding: 1em;
      border-radius: 6px;
      overflow-x: auto;
    }
    pre code {
      background-color: transparent;
      padding: 0;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>${escapeHtml(title)}</h1>
    <div class="metadata">
      Generated by PatmosLLM<br>
      ${timestamp.toLocaleDateString()} ${timestamp.toLocaleTimeString()}
    </div>
  </div>

  <div class="content">
    ${formatMarkdownToHTML(content)}
  </div>

  ${sources && sources.length > 0 ? `
    <div class="sources">
      <h3>Sources</h3>
      <ul>
        ${sources.map(s => `<li>${escapeHtml(s.title)}</li>`).join('\n')}
      </ul>
    </div>
  ` : ''}
</body>
</html>
  `

  // Launch Puppeteer and generate PDF
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  })

  try {
    const page = await browser.newPage()
    await page.setContent(html, { waitUntil: 'networkidle0' })

    const pdfBuffer = await page.pdf({
      format: 'Letter',
      printBackground: true,
      margin: {
        top: '1in',
        right: '1in',
        bottom: '1in',
        left: '1in'
      }
    })

    return Buffer.from(pdfBuffer)
  } finally {
    await browser.close()
  }
}

/**
 * Generate PowerPoint presentation from content using PptxGenJS
 */
export async function generatePPTX(metadata: DocumentMetadata): Promise<Buffer> {
  const { title, content, sources } = metadata

  const pptx = new pptxgen()

  // Set presentation properties
  pptx.author = 'PatmosLLM'
  pptx.title = title
  pptx.subject = 'AI-Generated Presentation'

  // Define theme colors
  const colors = {
    primary: '1e40af',
    secondary: '3b82f6',
    text: '1f2937',
    lightText: '6b7280'
  }

  // Title slide
  const titleSlide = pptx.addSlide()
  titleSlide.background = { color: colors.primary }

  titleSlide.addText(title, {
    x: 0.5,
    y: 2.0,
    w: 9,
    h: 1.5,
    fontSize: 44,
    bold: true,
    color: 'FFFFFF',
    align: 'center'
  })

  titleSlide.addText('Generated by PatmosLLM', {
    x: 0.5,
    y: 5.0,
    w: 9,
    h: 0.5,
    fontSize: 16,
    color: 'E5E7EB',
    align: 'center'
  })

  // Parse content into sections
  const sections = parseContentIntoSections(content)

  // Create slides for each section
  sections.forEach(section => {
    const slide = pptx.addSlide()

    // Section title
    slide.addText(section.heading, {
      x: 0.5,
      y: 0.5,
      w: 9,
      h: 0.75,
      fontSize: 32,
      bold: true,
      color: colors.primary
    })

    // Section content
    slide.addText(section.content, {
      x: 0.5,
      y: 1.5,
      w: 9,
      h: 4.5,
      fontSize: 16,
      color: colors.text,
      valign: 'top'
    })
  })

  // Sources slide
  if (sources && sources.length > 0) {
    const sourcesSlide = pptx.addSlide()

    sourcesSlide.addText('Sources', {
      x: 0.5,
      y: 0.5,
      w: 9,
      h: 0.75,
      fontSize: 32,
      bold: true,
      color: colors.primary
    })

    const sourcesList = sources.map(s => `â€¢ ${s.title}`).join('\n')
    sourcesSlide.addText(sourcesList, {
      x: 0.5,
      y: 1.5,
      w: 9,
      h: 4.5,
      fontSize: 14,
      color: colors.text,
      bullet: true
    })
  }

  // Generate and return buffer
  const buffer = await pptx.write({ outputType: 'nodebuffer' }) as Buffer
  return buffer
}

/**
 * Generate Excel spreadsheet from structured data using ExcelJS
 */
export async function generateXLSX(metadata: DocumentMetadata): Promise<Buffer> {
  const { title, content } = metadata

  const workbook = new ExcelJS.Workbook()
  workbook.creator = 'PatmosLLM'
  workbook.created = new Date()

  const worksheet = workbook.addWorksheet(title.substring(0, 31)) // Excel limit

  // Parse content into structured data
  const rows = parseContentIntoRows(content)

  // Add title row
  worksheet.addRow([title])
  worksheet.getCell('A1').font = { bold: true, size: 16, color: { argb: 'FF1e40af' } }
  worksheet.getCell('A1').alignment = { horizontal: 'center' }
  worksheet.mergeCells('A1:B1')

  // Add spacing
  worksheet.addRow([])

  // Add headers
  const headerRow = worksheet.addRow(['Topic', 'Details'])
  headerRow.font = { bold: true, color: { argb: 'FFFFFFFF' } }
  headerRow.fill = {
    type: 'pattern',
    pattern: 'solid',
    fgColor: { argb: 'FF1e40af' }
  }
  headerRow.alignment = { horizontal: 'center', vertical: 'middle' }

  // Add data rows
  rows.forEach(row => {
    const dataRow = worksheet.addRow(row)
    dataRow.alignment = { vertical: 'top', wrapText: true }
  })

  // Auto-fit columns
  worksheet.columns = [
    { width: 30 },
    { width: 60 }
  ]

  // Add borders
  worksheet.eachRow((row, rowNumber) => {
    if (rowNumber > 2) { // Skip title and spacing
      row.eachCell(cell => {
        cell.border = {
          top: { style: 'thin', color: { argb: 'FFE5E7EB' } },
          left: { style: 'thin', color: { argb: 'FFE5E7EB' } },
          bottom: { style: 'thin', color: { argb: 'FFE5E7EB' } },
          right: { style: 'thin', color: { argb: 'FFE5E7EB' } }
        }
      })
    }
  })

  // Freeze header row
  worksheet.views = [
    { state: 'frozen', ySplit: 3 }
  ]

  // Generate buffer
  const buffer = await workbook.xlsx.writeBuffer()
  return Buffer.from(buffer)
}

/**
 * Helper: Escape HTML special characters
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  }
  return text.replace(/[&<>"']/g, m => map[m])
}

/**
 * Helper: Convert markdown to HTML (basic implementation)
 */
function formatMarkdownToHTML(markdown: string): string {
  let html = markdown

  // Headers
  html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>')
  html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>')
  html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>')

  // Bold
  html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')

  // Italic
  html = html.replace(/\*(.*?)\*/g, '<em>$1</em>')

  // Lists (basic)
  html = html.replace(/^\* (.*$)/gim, '<li>$1</li>')
  html = html.replace(/^- (.*$)/gim, '<li>$1</li>')
  html = html.replace(/(<li>[\s\S]*?<\/li>)/g, '<ul>$1</ul>')

  // Paragraphs
  html = html.split('\n\n').map(para => {
    if (!para.startsWith('<')) {
      return `<p>${para}</p>`
    }
    return para
  }).join('\n')

  return html
}

/**
 * Helper: Parse content into PPTX sections
 */
function parseContentIntoSections(content: string): Array<{ heading: string; content: string }> {
  const sections: Array<{ heading: string; content: string }> = []

  // Split by headings (## or #)
  const parts = content.split(/^(#{1,2})\s+(.+)$/gm)

  if (parts.length <= 1) {
    // No headings found, create one section
    return [{ heading: 'Content', content: content.trim() }]
  }

  for (let i = 1; i < parts.length; i += 3) {
    const heading = parts[i + 1] || 'Section'
    const sectionContent = parts[i + 2] || ''
    sections.push({
      heading: heading.trim(),
      content: sectionContent.trim()
    })
  }

  return sections
}

/**
 * Helper: Parse content into Excel rows
 */
function parseContentIntoRows(content: string): string[][] {
  const rows: string[][] = []

  // Split by lines or sections
  const lines = content.split('\n').filter(line => line.trim())

  let currentTopic = ''
  let currentDetails: string[] = []

  lines.forEach(line => {
    // Check if it's a markdown heading
    if (line.match(/^#{1,3}\s+/)) {
      // Save previous section if exists
      if (currentTopic) {
        rows.push([currentTopic, currentDetails.join('\n')])
      }
      // Start new section
      currentTopic = line.replace(/^#{1,3}\s+/, '').trim()
      currentDetails = []
    }
    // Check if it's a bold heading (e.g., **Day 1:** or **Topic:**)
    else if (line.match(/^\*\*([^*]+)\*\*:?\s*/)) {
      // Save previous section if exists
      if (currentTopic) {
        rows.push([currentTopic, currentDetails.join('\n')])
      }
      // Start new section - extract text between ** markers
      currentTopic = line.replace(/^\*\*([^*]+)\*\*:?\s*/, '$1').trim()
      // If there's content after the bold heading, add it to details
      const remainingContent = line.replace(/^\*\*[^*]+\*\*:?\s*/, '').trim()
      currentDetails = remainingContent ? [remainingContent] : []
    }
    // Check if it's a numbered/bulleted list item that could be a topic
    else if (line.match(/^[\d]+\.\s+\*\*/) || line.match(/^-\s+\*\*/)) {
      // Save previous section if exists
      if (currentTopic) {
        rows.push([currentTopic, currentDetails.join('\n')])
      }
      // Extract topic from list item with bold
      const match = line.match(/^[\d-]+[.\s]+\*\*([^*]+)\*\*:?\s*(.*)/)
      if (match) {
        currentTopic = match[1].trim()
        currentDetails = match[2] ? [match[2].trim()] : []
      } else {
        currentDetails.push(line.trim())
      }
    }
    else {
      // Add to current details
      currentDetails.push(line.trim())
    }
  })

  // Add last section
  if (currentTopic) {
    rows.push([currentTopic, currentDetails.join('\n')])
  }

  // If no structure found, try to split by paragraphs (double newlines)
  if (rows.length === 0) {
    const paragraphs = content.split(/\n\n+/).filter(p => p.trim())

    if (paragraphs.length > 1) {
      // Use first sentence of each paragraph as topic
      paragraphs.forEach((para, i) => {
        const sentences = para.split(/[.!?]\s/)
        const topic = sentences[0]?.substring(0, 80) || `Section ${i + 1}`
        const details = sentences.slice(1).join('. ')
        rows.push([topic, details || para])
      })
    } else {
      // Last resort: put everything in one row
      rows.push(['Content', content])
    }
  }

  return rows
}
